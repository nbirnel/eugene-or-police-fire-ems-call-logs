#!/usr/bin/env python3

from datetime import timedelta

from coeapps import (
    get_driver,
    configure_logging,
    logging,
    new_parser,
    row_as_list_of_text,
    write_file,
    DAY_FORMAT,
    By,
    EC,
    Select,
    TimeoutException,
    WebDriverWait,
)


def get_rows(driver, current):

    year = current.strftime("%Y")  # 2018
    month = current.strftime("%b")  # Jan Feb Mar
    day = current.strftime("%-d")  # 1 2 3
    iso_format = current.strftime("%Y%m%d")
    logging.info("starting %s", iso_format)
    driver.implicitly_wait(0.5)

    calendar = driver.find_element(By.ID, "calendar")

    # Year options are generated dynamically in a 21 year range, so
    # we may need to click around to make our year visible.
    while True:
        year_element = calendar.find_element(
            By.CLASS_NAME, "ui-datepicker-year"
        )
        year_select = Select(year_element)
        years = [option.text for option in year_select.options]

        if year < years[0]:
            year_select.select_by_visible_text(years[0])
        if year > years[-1]:
            year_select.select_by_visible_text(years[-1])
        if year in years:
            year_select.select_by_visible_text(year)
            break

    month_element = calendar.find_element(
        By.CLASS_NAME, "ui-datepicker-month"
    )
    month_select = Select(month_element)
    month_select.select_by_visible_text(month)

    day_table = calendar.find_element(By.CLASS_NAME, "ui-datepicker-calendar")
    day_body = day_table.find_element(By.XPATH, "//tbody")
    days = day_body.find_elements(By.XPATH, "//a[@href='#']")
    day_to_click = next(filter(lambda x: x.text == day, days))
    day_to_click.click()

    delay = 10
    try:
        wrapper = WebDriverWait(driver, delay).until(
            EC.presence_of_element_located((By.XPATH, "//table[@id='calls']"))
        )

        table = driver.find_element(By.XPATH, "//table[@id='calls']")
        body = table.find_element(By.XPATH, ".//tbody")
        rows = body.find_elements(By.XPATH, ".//tr")

        summary = driver.find_element(
            By.XPATH, "//tr[@id='callSummary']/td/h4"
        ).text
        number_of_calls = int(summary.split(":")[1].strip())
        if number_of_calls != len(rows):
            logging.error(
                "%s expected %d calls, got %d",
                iso_format,
                number_of_calls,
                len(rows),
            )
        return [row_as_list_of_text(row) for row in rows]
    except TimeoutException:
        logging.error("%s timeout", iso_format)
        return None


def main():
    parser = new_parser()
    args = parser.parse_args()
    current, last = get_current_last(args)

    configure_logging("fetch-fire-ems-log.log", args.log_level)
    logging.info("started with %s", args)

    dispatch = "https://coeapps.eugene-or.gov/ruralfirecad"
    header = (
        "event_number",
        "agency",
        "dispatch_time",
        "area",
        "location",
        "city",
        "description",
    )

    driver = get_driver()
    driver.get(dispatch)

    while current <= last:
        try:
            rows = get_rows(driver, current)
            write_file(rows, current.strftime(DAY_FORMAT), "fire-ems", header)
        except Exception as error:
            logging.error("%s failed to get rows: %s", current, error)
        current = current + timedelta(days=1)

    driver.quit()


if __name__ == "__main__":
    main()
